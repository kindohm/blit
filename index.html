<html>
  <head>
    <style>
      body {
        background-color: #000;
        padding: 20px;
      }
      #canvas {
        border: solid 2px #333;
      }
      #score {
        position: fixed;
        left: 35;
        top: 120;
        font-size: 330px;
        font-family: monospace;
        color: #0077ff33;
      }
    </style>
  </head>
  <body>
    <div>
      <canvas id="canvas"></canvas>
      <span id="score">0000</span>
    </div>
    <script src="lib/coquette-min.js"></script>
    <script>
      const WIDTH = 800;
      const HEIGHT = 600;
      const PLAYER_MOVE_SPEED = 6;
      const PLAYER_SIZE = 15;
      const BULLET_SIZE = 4;
      const DIRECTIONS = { right: 0, left: 1 };
      const BASE_SPEED = 0.6;
      const Y_INC = 10;
      const SPEED_MULT = 0.015;
      const MAX_ENEMY_SIZE = 20;
      const ENEMY_SIZE_RATIO = 0.5;

      let x = false,
        enemyRows = 5,
        enemyCols = 6;

      class HitEvent extends EventTarget {
        hit() {
          this.dispatchEvent(new Event("hit"));
        }
      }

      const hitEvent = new HitEvent();

      const Game = function () {
        this.c = new Coquette(this, "canvas", WIDTH, HEIGHT, "#000");

        const scoreSpan = document.getElementById("score");

        let score = 0;

        hitEvent.addEventListener("hit", (e) => {
          score++;
          scoreSpan.innerHTML = score.toString().padStart(4, "0");
        });

        this.gameOver = false;

        // player
        this.c.entities.create(Player, {
          center: { x: WIDTH / 2, y: HEIGHT - 50 },
          color: "#07f",
        });

        // enemy array
        let currentEnemyArray = this.c.entities.create(EnemyArray, {
          color: "#07f",
          rows: 5,
          cols: 5,
        });

        this.update = function () {
          const entities = this.c.entities.all();
          const player = entities.find((e) => e instanceof Player);
          const ea = entities.find((e) => e instanceof EnemyArray);

          if (player.dead || ea.bottomedOut) {
            this.gameOver = true;
            return;
          }

          entities.forEach((entity) => {
            if (entity.dead) {
              this.c.entities.destroy(entity);
            }
          });

          const enemyArray = this.c.entities.all(EnemyArray);
          if (enemyArray.length === 0) {
            const bullets = this.c.entities.all(Bullet);
            bullets.forEach((b) => this.c.entities.destroy(b));

            enemyRows++;
            enemyCols++;

            // enemy array
            this.c.entities.create(EnemyArray, {
              color: "#07f",
              rows: enemyRows,
              cols: enemyCols,
            });
          }
        };
      };

      const EnemyArray = function (game, settings) {
        this.c = game.c;

        this.speed = BASE_SPEED;
        this.size = { x: WIDTH * 0.666, y: HEIGHT * 0.333 };
        this.center = { x: WIDTH / 2, y: 50 + this.size.y / 2 };
        this.direction = DIRECTIONS.right;
        this.killed = 0;

        for (let i in settings) {
          this[i] = settings[i];
        }

        const colSize = this.size.x / this.cols;
        const rowSize = this.size.y / this.rows;

        this.totalEnemies = this.rows * this.cols;

        for (let r = 0; r < this.rows; r++) {
          for (let c = 0; c < this.cols; c++) {
            this.c.entities.create(Enemy, {
              color: "#0f7",
              row: r,
              col: c,
              center: { x: 0, y: 0 },
              size: {
                x: Math.min(colSize * 0.8, MAX_ENEMY_SIZE),
                y: Math.min(rowSize * 0.8, MAX_ENEMY_SIZE),
              },
            });
          }
        }

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          const enemies = this.c.entities.all(Enemy);

          this.killed = this.totalEnemies - enemies.length;

          if (enemies.length === 0) {
            this.dead = true;
            return;
          }

          const leftMostEnemy = enemies.sort((a, b) =>
            a.center.x < b.center.x ? -1 : 1
          )[0];
          const rightMostEnemy = enemies.sort((a, b) =>
            a.center.x > b.center.x ? -1 : 1
          )[0];
          const bottomMostEnemy = enemies.sort((a, b) =>
            a.center.y > b.center.y ? -1 : 1
          )[0];

          const rightEnemyEdge =
            rightMostEnemy.center.x + rightMostEnemy.size.x / 2; // this.center.x + this.size.x/2;
          const leftEnemyEdge =
            leftMostEnemy.center.x - leftMostEnemy.size.x / 2; // this.center.x - this.size.x/2;
          const bottomEnemyEdge =
            bottomMostEnemy.center.y + bottomMostEnemy.size.y / 2; // this.center.y + this.size.y / 2;
          const topEdge = this.center.y - this.size.y / 2;
          const leftEdge = this.center.x - this.size.x / 2;

          if (bottomEnemyEdge >= HEIGHT) {
            this.bottomedOut = true;
            return;
          }

          if (rightEnemyEdge >= WIDTH) {
            this.direction = DIRECTIONS.left;
            this.center.y += Y_INC;
          } else if (leftEnemyEdge <= 0) {
            this.direction = DIRECTIONS.right;
            this.center.y += Y_INC;
          }

          const killed = this.totalEnemies - enemies.length;
          this.speed = BASE_SPEED + killed * SPEED_MULT;

          this.center.x +=
            this.direction === DIRECTIONS.right ? this.speed : -this.speed;

          enemies.forEach((enemy) => {
            const { row, col } = enemy;
            const x = colSize * col + colSize / 2 + leftEdge;
            const y = rowSize * row + rowSize / 2 + topEdge;
            enemy.center.x = x;
            enemy.center.y = y;
          });
        };
      };

      const Enemy = function (game, settings) {
        this.c = game.c;

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.draw = function (ctx) {
          ctx.strokeStyle = settings.color;
          ctx.strokeRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };

        this.collision = function (other) {
          if (!this.dead && other instanceof Bullet) {
            hitEvent.hit();
            other.dead = true;
            this.dead = true;
          }
        };
      };

      const Bullet = function (game, settings) {
        this.c = game.c;
        this.size = { x: BULLET_SIZE, y: BULLET_SIZE };
        this.vector = { x: 0, y: -10 };

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          this.center.y += this.vector.y;
          if (this.center.y < 0) {
            this.dead = true;
          }
        };

        this.draw = function (ctx) {
          ctx.fillStyle = settings.color;
          ctx.fillRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };
      };

      const Player = function (game, settings) {
        this.c = game.c;
        this.size = { x: PLAYER_SIZE, y: PLAYER_SIZE };
        this.bulletTicks = 0;

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          this.bulletTicks++;

          if (this.c.inputter.isDown(this.c.inputter.LEFT_ARROW)) {
            this.center.x = Math.max(
              this.center.x - PLAYER_MOVE_SPEED,
              this.size.x / 2
            );
          }
          if (this.c.inputter.isDown(this.c.inputter.RIGHT_ARROW)) {
            this.center.x = Math.min(
              this.center.x + PLAYER_MOVE_SPEED,
              WIDTH - this.size.x / 2
            );
          }

          if (
            this.c.inputter.isDown(this.c.inputter.SPACE) &&
            this.bulletTicks > 3
          ) {
            // spawn a bullet
            this.c.entities.create(Bullet, {
              center: {
                x: this.center.x,
                y: this.center.y - this.size.y / 2 - 2,
              },
              color: settings.color,
            });

            this.bulletTicks = 0;
          }
        };

        this.draw = function (ctx) {
          ctx.fillStyle = settings.color;
          ctx.fillRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };

        this.collision = function (other) {
          if (other instanceof Enemy) {
            this.dead = true;
          }
        };
      };

      window.addEventListener("load", function () {
        new Game();
      });
    </script>
  </body>
</html>
