<!DOCTYPE html>
<!--
  Hey. Use arrow keys to move. Use space bar to fire.
-->
<html>
  <head>
    <style>
      body {
        background-color: #000;
        padding: 20px;
      }
      #container {
        position: relative;
        display: inline-block;
      }
      #canvas {
        position: absolute;
        border: solid 2px #333;
      }
      #score {
        position: absolute;
        left: 0px;
        top: 120px;
        font-size: 330px;
        font-family: monospace;
        color: #0077ff33;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="canvas" width="800" height="600"></canvas>
      <span id="score">0000</span>
    </div>
    <script src="lib/coquette-min.js"></script>
    <script>
      const WIDTH = 800;
      const HEIGHT = 600;
      const PLAYER_MOVE_SPEED = 6;
      const PLAYER_SIZE = 15;
      const BULLET_SIZE = 4;
      const DIRECTIONS = { right: 0, left: 1 };
      const BASE_SPEED = 0.6;
      const TOP_SPEED = 4;
      const Y_INC = 10;
      const MAX_ENEMY_SIZE = 20;
      const ENEMY_SIZE_RATIO = 0.5;
      const ENEMY_ROWS = 6;
      const ENEMY_COLS = 10;
      const GROUPS = { ENEMY: 1, PLAYER: 2 };

      class HitEvent extends EventTarget {
        hit() {
          this.dispatchEvent(new Event("hit"));
        }
      }

      const hitEvent = new HitEvent();

      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive
      }

      function convertRange(value, r1, r2) {
        return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];
      }

      const Game = function () {
        this.c = new Coquette(this, "canvas", WIDTH, HEIGHT, "#000");

        const scoreSpan = document.getElementById("score");

        let score = 0;
        let rounds = 1;
        let bombProb = 0.01;

        hitEvent.addEventListener("hit", (e) => {
          score++;
          scoreSpan.innerHTML = score.toString().padStart(4, "0");
        });

        this.gameOver = false;

        // player
        this.c.entities.create(Player, {
          center: { x: WIDTH / 2, y: HEIGHT - 50 },
          color: "#07f",
        });

        this.createNewEnemyArray = function () {
          this.c.entities.create(EnemyArray, {
            color: "#07f",
            rows: ENEMY_ROWS,
            cols: ENEMY_COLS,
            baseSpeed: BASE_SPEED,
            topSpeed: TOP_SPEED,
            bombProb,
          });
        };

        this.createNewEnemyArray();

        let entities, player, enemyArray, bullets;

        this.update = function () {
          entities = this.c.entities.all();
          player = entities.find((e) => e instanceof Player);
          enemyArray = entities.find((e) => e instanceof EnemyArray);

          if (player.dead || enemyArray.bottomedOut) {
            this.gameOver = true;
            return;
          }

          if (enemyArray.cleared) {
            this.c.entities.destroy(enemyArray);

            bullets = this.c.entities.all(Bullet);
            bullets.forEach((b) => this.c.entities.destroy(b));

            bombProb *= 1.2;
            this.createNewEnemyArray();
          }
        };
      };

      const EnemyArray = function (game, settings) {
        this.c = game.c;

        this.size = { x: WIDTH * 0.75, y: HEIGHT * 0.4 };
        this.center = { x: WIDTH / 2, y: 50 + this.size.y / 2 };
        this.direction = DIRECTIONS.right;

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.speed = this.baseSpeed;

        const that = this;
        this.killed = 0;
        this.totalEnemies = this.rows * this.cols;

        function handleHit(target) {
          target.killed++;

          target.speed =
            target.killed == target.totalEnemies - 1
              ? TOP_SPEED * 1.2
              : convertRange(
                  target.killed,
                  [0, target.totalEnemies],
                  [target.baseSpeed, target.topSpeed]
                );
        }

        hitEvent.addEventListener("hit", () => handleHit(that));

        const colSize = this.size.x / this.cols;
        const rowSize = this.size.y / this.rows;
        const sizeX = Math.min(colSize * 0.8, MAX_ENEMY_SIZE);
        const sizeY = Math.min(rowSize * 0.8, MAX_ENEMY_SIZE);

        for (let r = 0; r < this.rows; r++) {
          for (let c = 0; c < this.cols; c++) {
            this.c.entities.create(Enemy, {
              color: "#0f7",
              row: r,
              col: c,
              center: { x: 0, y: 0 },
              size: {
                x: sizeX,
                y: sizeY,
              },
            });
          }
        }

        let enemies,
          leftMostEnemy,
          rightMostEnemy,
          bottomMostEnemy,
          rightEnemyEdge,
          leftEnemyEdge,
          bottomEnemyEdge,
          topEdge,
          leftEdge;

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          enemies = this.c.entities.all(Enemy);

          if (enemies.length === 0) {
            this.cleared = true;
            return;
          }

          leftMostEnemy = enemies.sort((a, b) =>
            a.center.x < b.center.x ? -1 : 1
          )[0];
          rightMostEnemy = enemies.sort((a, b) =>
            a.center.x > b.center.x ? -1 : 1
          )[0];
          bottomMostEnemy = enemies.sort((a, b) =>
            a.center.y > b.center.y ? -1 : 1
          )[0];

          rightEnemyEdge = rightMostEnemy.center.x + rightMostEnemy.size.x / 2; // this.center.x + this.size.x/2;
          leftEnemyEdge = leftMostEnemy.center.x - leftMostEnemy.size.x / 2; // this.center.x - this.size.x/2;
          bottomEnemyEdge =
            bottomMostEnemy.center.y + bottomMostEnemy.size.y / 2; // this.center.y + this.size.y / 2;
          topEdge = this.center.y - this.size.y / 2;
          leftEdge = this.center.x - this.size.x / 2;

          if (bottomEnemyEdge >= HEIGHT) {
            this.bottomedOut = true;
            return;
          }

          if (rightEnemyEdge >= WIDTH) {
            this.direction = DIRECTIONS.left;
            this.center.y += Y_INC;
          } else if (leftEnemyEdge <= 0) {
            this.direction = DIRECTIONS.right;
            this.center.y += Y_INC;
          }

          this.center.x +=
            this.direction === DIRECTIONS.right ? this.speed : -this.speed;

          enemies.forEach((enemy) => {
            enemy.center.x = colSize * enemy.col + colSize / 2 + leftEdge;
            enemy.center.y = rowSize * enemy.row + rowSize / 2 + topEdge;
          });

          if (Math.random() < this.bombProb) {
            const index = getRandomIntInclusive(0, enemies.length - 1);
            if (index <= enemies.length - 1) {
              enemies[index].dropBomb();
            }
          }
        };
      };

      const Enemy = function (game, settings) {
        this.c = game.c;
        this.group = GROUPS.ENEMY;

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.dropBomb = function () {
          // spawn a bullet
          this.c.entities.create(Bullet, {
            center: {
              x: this.center.x,
              y: this.center.y + this.size.y / 2,
            },
            vector: { x: 0, y: 5 },
            color: settings.color,
            group: this.group,
          });
        };

        this.draw = function (ctx) {
          ctx.strokeStyle = settings.color;
          ctx.strokeRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };

        this.collision = function (other) {
          if (other.group !== this.group && other instanceof Bullet) {
            hitEvent.hit();
            this.c.entities.destroy(this);
            this.c.entities.destroy(other);
          }
        };
      };

      const Bullet = function (game, settings) {
        this.c = game.c;
        this.size = { x: BULLET_SIZE, y: BULLET_SIZE };

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          this.center.y += this.vector.y;
          if (this.center.y < 0) {
            this.c.entities.destroy(this);
          }
        };

        this.draw = function (ctx) {
          ctx.fillStyle = settings.color;
          ctx.fillRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };
      };

      const Player = function (game, settings) {
        this.c = game.c;
        this.group = GROUPS.PLAYER;
        this.size = { x: PLAYER_SIZE, y: PLAYER_SIZE };
        this.bulletTicks = 0;

        for (let i in settings) {
          this[i] = settings[i];
        }

        this.update = function () {
          if (game.gameOver) {
            return;
          }

          this.bulletTicks++;

          if (
            this.c.inputter.isDown(this.c.inputter.LEFT_ARROW) ||
            this.c.inputter.isDown(this.c.inputter.A)
          ) {
            this.center.x = Math.max(
              this.center.x - PLAYER_MOVE_SPEED,
              this.size.x / 2
            );
          }
          if (
            this.c.inputter.isDown(this.c.inputter.RIGHT_ARROW) ||
            this.c.inputter.isDown(this.c.inputter.D)
          ) {
            this.center.x = Math.min(
              this.center.x + PLAYER_MOVE_SPEED,
              WIDTH - this.size.x / 2
            );
          }

          if (
            this.c.inputter.isDown(this.c.inputter.SPACE) &&
            this.bulletTicks > 3
          ) {
            // spawn a bullet
            this.c.entities.create(Bullet, {
              center: {
                x: this.center.x,
                y: this.center.y - this.size.y,
              },
              vector: { x: 0, y: -10 },
              color: settings.color,
              group: this.group,
            });

            this.bulletTicks = 0;
          }
        };

        this.draw = function (ctx) {
          ctx.fillStyle = settings.color;
          ctx.fillRect(
            this.center.x - this.size.x / 2,
            this.center.y - this.size.y / 2,
            this.size.x,
            this.size.y
          );
        };

        this.collision = function (other) {
          if (other.group !== this.group) {
            this.dead = true;
          }
        };
      };

      window.addEventListener("load", function () {
        new Game();
      });
    </script>
  </body>
</html>
